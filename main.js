// Generated by CoffeeScript 1.11.1
var SC, ToRad, addStaticBox, add_new_card, antialias, basicTexture, bodys, camera, canvas, clearMesh, controls, fps, geos, gradTexture, gravity, green, grounds, infos, init, initOimoPhysics, isMobile, light, main_loop, mats, meshs, onKey, onWindowResize, populate, renderer, rnd, scene, type, updateOimoPhysics, world;

camera = void 0;

scene = void 0;

light = void 0;

renderer = void 0;

canvas = void 0;

controls = void 0;

meshs = [];

grounds = [];

isMobile = false;

antialias = true;

green = 0x008356;

geos = {};

mats = {};

world = null;

bodys = [];

fps = [0, 0, 0, 0];

ToRad = 0.0174532925199432957;

type = 1;

infos = void 0;

rnd = Math.random;

SC = 1.0;

init = function() {
  var back, buffgeoBack, materialType, n;
  n = navigator.userAgent;
  if (n.match(/Android/i) || n.match(/webOS/i) || n.match(/iPhone/i) || n.match(/iPad/i) || n.match(/iPod/i) || n.match(/BlackBerry/i) || n.match(/Windows Phone/i)) {
    isMobile = true;
    antialias = false;
  }
  infos = document.getElementById('info');
  canvas = document.getElementById('canvas');
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, SC * 5000);
  camera.position.set(SC * 160, SC * 200, SC * 200);
  controls = new THREE.OrbitControls(camera, canvas);
  controls.target.set(0, SC * 20, 0);
  controls.update();
  scene = new THREE.Scene;
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    precision: 'mediump',
    antialias: antialias
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  materialType = 'MeshBasicMaterial';
  if (!isMobile) {
    scene.add(new THREE.AmbientLight(0x3D4143));
    light = new THREE.DirectionalLight(0xffffff, 1.4);
    light.position.set(SC * 300, SC * 1000, SC * 500);
    light.target.position.set(0, 0, 0);
    light.castShadow = true;
    light.shadowCameraNear = SC * 500;
    light.shadowCameraFar = SC * 1600;
    light.shadowCameraFov = 70;
    light.shadowBias = 0.0001;
    light.shadowDarkness = 0.7;
    light.shadowCameraVisible = true;
    light.shadowMapWidth = light.shadowMapHeight = 1024;
    scene.add(light);
    materialType = 'MeshPhongMaterial';
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap;
  }
  buffgeoBack = new THREE.BufferGeometry;
  buffgeoBack.fromGeometry(new THREE.IcosahedronGeometry(SC * 3000, 2));
  back = new THREE.Mesh(buffgeoBack, new THREE.MeshBasicMaterial({
    map: gradTexture([[0.75, 0.6, 0.4, 0.25], ['#008356', '#008356', '#FFFFFF', '#FFFFFF']]),
    side: THREE.BackSide,
    depthWrite: false,
    fog: true
  }));
  scene.add(back);
  geos['box'] = (new THREE.BufferGeometry).fromGeometry(new THREE.BoxGeometry(1, 1, 1));
  mats['box'] = new THREE[materialType]({
    shininess: 10,
    map: basicTexture(2),
    name: 'box'
  });
  mats['sbox'] = new THREE[materialType]({
    shininess: 10,
    map: basicTexture(3),
    name: 'sbox'
  });
  mats['ground'] = new THREE[materialType]({
    shininess: 10,
    color: 0x111111,
    transparent: true,
    opacity: 0.5
  });
  window.addEventListener('resize', onWindowResize, false);
  document.addEventListener('keyup', onKey, false);
  return initOimoPhysics();
};

main_loop = function() {
  updateOimoPhysics();
  renderer.render(scene, camera);
  return requestAnimationFrame(main_loop);
};

onWindowResize = function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(window.innerWidth, window.innerHeight);
};

onKey = function(e) {
  if (e.key === " ") {
    return add_new_card();
  }
};

addStaticBox = function(size, position, rotation) {
  var mesh;
  mesh = new THREE.Mesh(geos.box, mats.ground);
  mesh.scale.set(size[0], size[1], size[2]);
  mesh.position.set(position[0], position[1], position[2]);
  mesh.rotation.set(rotation[0] * ToRad, rotation[1] * ToRad, rotation[2] * ToRad);
  scene.add(mesh);
  grounds.push(mesh);
  mesh.castShadow = true;
  return mesh.receiveShadow = true;
};

clearMesh = function() {
  var i;
  i = meshs.length;
  while (i--) {
    scene.remove(meshs[i]);
  }
  i = grounds.length;
  while (i--) {
    scene.remove(grounds[i]);
  }
  grounds = [];
  return meshs = [];
};

initOimoPhysics = function() {
  world = new OIMO.World(1 / 60, 2, 32);
  return populate();
};

populate = function() {
  var max, phone, table;
  max = 20;
  clearMesh();
  world.clear();
  bodys = [];
  table = world.add({
    size: [SC * 400, SC * 80, SC * 400],
    pos: [0, -SC * 40, 0],
    world: world
  });
  phone = world.add({
    size: [SC * 100, SC * 20, SC * 180],
    pos: [0, SC * 20, 0],
    world: world
  });
  return addStaticBox([SC * 100, SC * 20, SC * 180], [0, SC * 20, 0], [0, 0, 0]);
};

add_new_card = function() {
  var body, d, h, mesh, w, x, y, z;
  x = (rnd() - rnd()) * SC * 10;
  z = (rnd() - rnd()) * SC * 10;
  y = SC * 200;
  w = SC * 50;
  h = SC * 2;
  d = SC * 90;
  body = world.add({
    type: 'box',
    size: [w, h, d],
    pos: [x, y, z],
    rot: [(rnd() - rnd()) * 15, (rnd() - rnd()) * 45, (rnd() - rnd()) * 15],
    move: true,
    config: [1.0, 0.4, 0.0, 1, 0xffffffff],
    world: world
  });
  bodys.push(body);
  mesh = new THREE.Mesh(geos.box, mats.box);
  mesh.scale.set(w, h, d);
  mesh.quaternion.copy(body.getQuaternion());
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  meshs.push(mesh);
  return scene.add(mesh);
};

updateOimoPhysics = function() {
  var body, i, mesh, x, y, z;
  if (world === null) {
    return;
  }
  world.step();
  i = bodys.length;
  while (i--) {
    body = bodys[i];
    mesh = meshs[i];
    if (!body.sleeping) {
      mesh.position.copy(body.getPosition());
      mesh.quaternion.copy(body.getQuaternion());
      if (mesh.material.name === 'sbox') {
        mesh.material = mats.box;
      }
      if (mesh.position.y < -100) {
        x = (rnd() - rnd()) * SC * 10;
        z = (rnd() - rnd()) * SC * 10;
        y = 100 + rnd() * SC * 1000;
        body.resetPosition(x, y, z);
        body.resetRotation(0, 0, 0);
      }
    } else {
      if (mesh.material.name === 'box') {
        mesh.material = mats.sbox;
      }
    }
  }
  return infos.innerHTML = world.performance.show();
};

gravity = function(g) {
  return world.gravity = new OIMO.Vec3(0, -g, 0);
};

gradTexture = function(color) {
  var c, ct, gradient, i, size, texture;
  c = document.createElement('canvas');
  ct = c.getContext('2d');
  size = 1024;
  c.width = 16;
  c.height = size;
  gradient = ct.createLinearGradient(0, 0, 0, size);
  i = color[0].length;
  while (i--) {
    gradient.addColorStop(color[0][i], color[1][i]);
  }
  ct.fillStyle = gradient;
  ct.fillRect(0, 0, 16, size);
  texture = new THREE.Texture(c);
  texture.needsUpdate = true;
  return texture;
};

basicTexture = function(n) {
  var canvas;
  var color, ctx, tx;
  canvas = document.createElement('canvas');
  canvas.width = canvas.height = 64;
  ctx = canvas.getContext('2d');
  color = void 0;
  if (n === 0) {
    color = '#3884AA';
  }
  if (n === 1) {
    color = '#61686B';
  }
  if (n === 2) {
    color = '#CCCCCC';
  }
  if (n === 3) {
    color = '#AAAAAA';
  }
  if (n === 4) {
    color = '#AAAA38';
  }
  if (n === 5) {
    color = '#61686B';
  }
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, 64, 64);
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(0, 0, 32, 32);
  ctx.fillRect(32, 32, 32, 32);
  tx = new THREE.Texture(canvas);
  tx.needsUpdate = true;
  return tx;
};

init();

main_loop();
